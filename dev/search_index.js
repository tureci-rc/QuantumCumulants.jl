var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-Hilbert-Spaces","page":"API","title":"Hilbert Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HilbertSpace","category":"page"},{"location":"api/#Qumulants.HilbertSpace","page":"API","title":"Qumulants.HilbertSpace","text":"HilbertSpace\n\nAbstract type for representing Hilbert spaces.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"ProductSpace","category":"page"},{"location":"api/#Qumulants.ProductSpace","page":"API","title":"Qumulants.ProductSpace","text":"ProductSpace <: HilbertSpace\n\nStores a composite HilbertSpace consisting of multiple subspaces. Generally created by computing the tensor product ‚äó of subspaces.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"FockSpace","category":"page"},{"location":"api/#Qumulants.FockSpace","page":"API","title":"Qumulants.FockSpace","text":"FockSpace <: HilbertSpace\n\nHilbertSpace defining a Fock space for bosonic operators. See also: Destroy, Create\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"NLevelSpace","category":"page"},{"location":"api/#Qumulants.NLevelSpace","page":"API","title":"Qumulants.NLevelSpace","text":"NLevelSpace <: HilbertSpace\nNLevelSpace(name::Symbol,levels,GS=1)\n\nDefine a HilbertSpace for an object consisting of N discrete energy levels. The given levels must be an integer specifying the number of levels, or an iterable collection of levels. The argument GS specifies which state should be treated as ground state and is rewritten using population conservation during simplification. See also: Transition\n\nExamples:\n\njulia> ha = NLevelSpace(:a,3)\n‚Ñã(a)\n\njulia> ha = NLevelSpace(:a,(:g,:e))\n‚Ñã(a)\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"‚äó","category":"page"},{"location":"api/#Qumulants.:‚äó","page":"API","title":"Qumulants.:‚äó","text":"‚äó(spaces::HilbertSpace...)\n\nCreate a ProductSpace consisting of multiple subspaces.\n\nExamples\n\njulia> hf = FockSpace(:f)\n‚Ñã(f)\n\njulia> ha = NLevelSpace(:a,2)\n‚Ñã(a)\n\njulia> h = hf‚äóha\n‚Ñã(f) ‚äó ‚Ñã(a)\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Operators","page":"API","title":"Operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractOperator","category":"page"},{"location":"api/#Qumulants.AbstractOperator","page":"API","title":"Qumulants.AbstractOperator","text":"AbstractOperator\n\nAbstract type representing any expression involving operators.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"BasicOperator","category":"page"},{"location":"api/#Qumulants.BasicOperator","page":"API","title":"Qumulants.BasicOperator","text":"BasicOperator <: AbstractOperator\n\nAbstract type representing fundamental operator types.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"OperatorTerm","category":"page"},{"location":"api/#Qumulants.OperatorTerm","page":"API","title":"Qumulants.OperatorTerm","text":"OperatorTerm <: AbstractOperator\n\nSymbolic expression tree consisting of AbstractOperator and Number arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Destroy","category":"page"},{"location":"api/#Qumulants.Destroy","page":"API","title":"Qumulants.Destroy","text":"Destroy <: BasicOperator\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator annihilation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Create","category":"page"},{"location":"api/#Qumulants.Create","page":"API","title":"Qumulants.Create","text":"Create <: BasicOperator\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator creation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Transition","category":"page"},{"location":"api/#Qumulants.Transition","page":"API","title":"Qumulants.Transition","text":"Transition <: BasicOperator\nTransition(h::NLevelSpace,name::Symbol,i,j)\n\nFundamental operator defining a transition from level j to level i on a NLevelSpace. The notation corresponds to Dirac notation, i.e. the above is equivalent to |i‚ü©‚ü®j|.\n\nExamples\n\njulia> ha = NLevelSpace(:a,(:g,:e))\n‚Ñã(a)\n\njulia> œÉ = Transition(ha,:œÉ,:g,:e)\nœÉge\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Heisenberg","page":"API","title":"Heisenberg","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"heisenberg","category":"page"},{"location":"api/#Qumulants.heisenberg","page":"API","title":"Qumulants.heisenberg","text":"heisenberg(ops::Vector,H::AbstractOperator)\nheisenberg(op::AbstractOperator,H::AbstractOperator)\n\nCompute a set of Heisenberg equations of the operators in ops under the Hamiltonian H.\n\n\n\n\n\nheisenberg(ops::Vector,H::AbstractOperator,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\nheisenberg(op::AbstractOperator,H::AbstractOperator,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\n\nCompute the set of equations for the operators in ops under the Hamiltonian H and with loss operators contained in J. The resulting equation is equivalent to the Quantum-Langevin equation where noise is neglected.\n\nArguments\n\n*ops::Vector{<:AbstractVector}: The operators of which the equations are to be computed. *H::AbstractOperatr: The Hamiltonian describing the reversible dynamics of the     system. *J::Vector{<:AbstractOperator}: A vector containing the collapse operators of     the system. A term of the form     sum_i J_i^dagger O J_i - frac12left(J_i^dagger J_i O + OJ_i^dagger J_iright)     is added to the Heisenberg equation.\n\nOptional argumentes\n\n*Jdagger::Vector=adjoint.(J): Vector containing the hermitian conjugates of     the collapse operators. *rates=ones(length(J)): Decay rates corresponding to the collapse operators in J.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"commutator","category":"page"},{"location":"api/#Qumulants.commutator","page":"API","title":"Qumulants.commutator","text":"commutator(a,b; simplify=true, kwargs...)\n\nComputes the commutator a*b - b*a of a and b. If simplify is true, the result is simplified using the simplify_operators function. Further keyword arguments are passed to simplification.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"acts_on","category":"page"},{"location":"api/#Qumulants.acts_on","page":"API","title":"Qumulants.acts_on","text":"acts_on(op::AbstractOperator)\n\nShows on which Hilbert space op acts. For BasicOperator types, this returns an Integer, whereas for a OperatorTerm it returns a Vector{Int} whose entries specify all subspaces on which the expression acts.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Differential-equations","page":"API","title":"Differential Equations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractEquation","category":"page"},{"location":"api/#Qumulants.AbstractEquation","page":"API","title":"Qumulants.AbstractEquation","text":"Abstract type for equations.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DifferentialEquation","category":"page"},{"location":"api/#Qumulants.DifferentialEquation","page":"API","title":"Qumulants.DifferentialEquation","text":"DifferentialEquation{LHS,RHS,H,J,R} <: AbstractEquation{LHS,RHS}\nDifferentialEquation(lhs,rhs,H,J,rates)\n\nType defining a system of differential equations, where lhs is a vector of derivatives and rhs is a vector of expressions. In addition, it keeps track of the Hamiltonian, the collapse operators and the corresponding decay rates of the system.\n\nFields\n\n*lhs: Vector of operators or averages of which the derivatives are taken. *rhs: Vector of expressions to which the derivatives are equal. *hamiltonian: Operator defining the system Hamiltonian. *jumps: Vector of operators specifying the decay processes. *rates: Decay rates corresponding to the jumps.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Symbolic-numbers","page":"API","title":"Symbolic Numbers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SymbolicNumber","category":"page"},{"location":"api/#Qumulants.SymbolicNumber","page":"API","title":"Qumulants.SymbolicNumber","text":"SymbolicNumber <: Number\n\nAbstract type for all symbolic numbers, i.e. Parameter, Average and corresponding expression trees.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"NumberTerm","category":"page"},{"location":"api/#Qumulants.NumberTerm","page":"API","title":"Qumulants.NumberTerm","text":"NumberTerm <: SymbolicNumber\n\nExpression tree consisting of SymbolicNumber variables.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Parameter","category":"page"},{"location":"api/#Qumulants.Parameter","page":"API","title":"Qumulants.Parameter","text":"Parameter <: SymbolicNumber\n\nA parameter represented as a symbolic. See also: parameters, @parameters\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"parameters","category":"page"},{"location":"api/#Qumulants.parameters","page":"API","title":"Qumulants.parameters","text":"parameters(symbols::Symbol...)\nparamters(s::String)\n\nCreate symbolic parameters.\n\nExpamples\n\njulia> ps = parameters(:a, :b)\n(a, b)\n\njulia> parameters(\"a b\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"@parameters","category":"page"},{"location":"api/#Qumulants.@parameters","page":"API","title":"Qumulants.@parameters","text":"@parameters(ps...)\n\nConvenience macro to quickly define symbolic parameters.\n\nExamples\n\njulia> @parameters œâ Œ∫\n(œâ, Œ∫)\n\n\n\n\n\n","category":"macro"},{"location":"api/#API:-Simplify","page":"API","title":"Simplification","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"simplify_operators","category":"page"},{"location":"api/#Qumulants.simplify_operators","page":"API","title":"Qumulants.simplify_operators","text":"simplify_operators(op::AbstractOperator; rewriter=default_operator_simplifier(), kwargs...)\n\nSimplify an operator through standard algebraic rewriting, as well as using fundamental commutation relations.\n\nArguments\n\n===========\n\nop: The operator expression to be simplified.\nrewriter: The rewriter used.\nkwargs: Further arguments passed to SymbolicUtils.simplify.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"simplify_constants","category":"page"},{"location":"api/#Qumulants.simplify_constants","page":"API","title":"Qumulants.simplify_constants","text":"simplify_constants(t::NumberTerm;kwargs...)\n\nStandard simplification for SymbolicNumber types. Converts to a SymbolicUtils expression and uses its standard simplification routines for symbolic number variables.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"expand","category":"page"},{"location":"api/#Qumulants.expand","page":"API","title":"Qumulants.expand","text":"expand(ex; rewriter=defualt_expand_simplifier(), kwargs...)\n\nSimple wrapper around SymbolicUtils.simplify that uses a rewriter such that expressions are expanded.\n\nArguments\n\n===========\n\nex: The expression to be expanded.\nrewriter: The used rewriter.\nkwargs: Further arguments passed to SymbolicUtils.simplify.\n\nExamples\n\njulia> @parameters p q r\n(p, q, r)\n\njulia> ex = p*(q+r) + (q+p)*(r+q)\n((p*(q+r))+((q+p)*(r+q)))\n\njulia> expand(ex)\n((p*q)+(p*r)+(q*r)+(p*r)+(q*q)+(p*q))\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"substitute","category":"page"},{"location":"api/#Qumulants.substitute","page":"API","title":"Qumulants.substitute","text":"substitute(arg, subs; simplify=true)\n\nSubstitute the symbolic argument, i.e. any subtype to AbstractOperator or SymbolicNumber according to the substitutions stored in a Dict. Also works on DifferentialEquation. If simplify=true, the output is simplified.\n\nExamples\n\njulia> @parameters p\n(p,)\n\njulia> substitute(p, Dict(p=>2))\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Average","page":"API","title":"Average","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Average","category":"page"},{"location":"api/#Qumulants.Average","page":"API","title":"Qumulants.Average","text":"Average <: SymbolicNumber\n\nSymbolic number representing the average over an operator. See also: average\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"average","category":"page"},{"location":"api/#Qumulants.average","page":"API","title":"Qumulants.average","text":"average(::AbstractOperator)\naverage(::AbstractOperator,order::Int)\n\nCompute the average of an operator. If order is given, the cumulant_expansion up to that order is computed immediately.\n\n\n\n\n\naverage(::DifferentialEquation;multithread=false)\naverage(::DifferentialEquation,order::Int;multithread=false)\n\nCompute the average of a DifferentialEquation (or a set of equations). Returns a DifferentialEquation with containing the corresponding equations for averages. If order is specified, the cumulant_expansion up to that order is computed immediately. The keyword multithread specifies whether the averaging (and cumulant_expansion) should be parallelized (defaults to false).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"cumulant_expansion","category":"page"},{"location":"api/#Qumulants.cumulant_expansion","page":"API","title":"Qumulants.cumulant_expansion","text":"cumulant_expansion(avg, order::Int)\n\nFor an Average of an operator, expand it in terms of moments up to order neglecting their joint cumulant.\n\nSee also: https://en.wikipedia.org/wiki/Cumulant#Joint_cumulants\n\nExamples\n\njulia> avg = average(a*b)\n‚ü®a*b‚ü©\n\njulia> cumulant_expansion(avg,1)\n(‚ü®a‚ü©*‚ü®b‚ü©)\n\njulia> avg = average(a*b*c)\n‚ü®a*b*c‚ü©\n\njulia> cumulant_expansion(avg,2)\n((‚ü®a*b‚ü©*‚ü®c‚ü©)+(‚ü®a*c‚ü©*‚ü®b‚ü©)+(‚ü®a‚ü©*‚ü®b*c‚ü©)+(-2*‚ü®a‚ü©*‚ü®b‚ü©*‚ü®c‚ü©))\n\nOptional arguments\n\n*simplify=true: Specify whether the result should be simplified. *kwargs...: Further keyword arguments being passed to simplify_constants\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"cumulant","category":"page"},{"location":"api/#Qumulants.cumulant","page":"API","title":"Qumulants.cumulant","text":"cumulant(x,n=get_order(x);simplify=true,kwargs...)\n\nCompute the nth cumulant of x (either an operator or an average). The output is simplified when simplify=true. Further keyword arguments are passed on to simplification.\n\nExamples\n\njulia> cumulant(a)\n‚ü®a‚ü©\n\njulia> cumulant(a*b)\n(‚ü®a*b‚ü©+(-1*‚ü®a‚ü©*‚ü®b‚ü©))\n\njulia> cumulant(a*b,1)\n‚ü®a*b‚ü©\n\njulia> cumulant(a*b,3)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_order","category":"page"},{"location":"api/#Qumulants.get_order","page":"API","title":"Qumulants.get_order","text":"get_order(arg)\n\nCompute the order of a given argument. This is the order used to decide whether something should be expanded using a cumulant_expansion method.\n\nExamples\n\njulia> get_order(a)\n1\n\njulia> get_order(a*b)\n2\n\njulia> get_order(1)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-DiffEq","page":"API","title":"Function generation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"build_ode","category":"page"},{"location":"api/#Qumulants.build_ode","page":"API","title":"Qumulants.build_ode","text":"build_ode(rhs::Vector, vs::Vector, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\nFrom a set of equations contained in eqs, generate a Meta.Expr containing the code for a function which can be directly passed to OrdinaryDiffEq in order to solve it. The variable vector u corresponds to the symbols provided in vs.\n\nArguments\n\n*eqs::Vector: The vector containing the right-hand side of equations. *vs::Vector: The vector containing the left-hand side of equations. *ps=[]: List of (symbolic) parameters, which are parsed into parameters     used in DiffEq functions. *usym=:u: The symbol used for the variable vector. *psym=:p: The symbol used for the parameter vector. *tsym=:t: The symbol used for the time parameter.\n\nOptional arguments\n\n*check_bounds::Bool=false: Choose whether the resulting function should contain     the @inbounds flag, which skips bounds checking for performance.\n\n\n\n\n\nbuild_ode(eqs::DifferentialEquation, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\nFrom a set of differential equationseqs of averages, generate a Meta.Expr containing the code for a function which can be directly passed to OrdinaryDiffEq in order to solve it.\n\nArguments\n\n*eqs::DifferentialEquation: The set of (average) equations. *ps=[]: List of symbolic parameters, which are parsed into parameters     used in DiffEq functions. *usym=:u: The symbol used for the variable vector. *psym=:p: The symbol used for the parameter vector. *tsym=:t: The symbol used for the time parameter.\n\nOptional arguments\n\n*check_bounds::Bool=false: Choose whether the resulting function should contain     the @inbounds flag, which skips bounds checking for performance.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"generate_ode","category":"page"},{"location":"api/#Qumulants.generate_ode","page":"API","title":"Qumulants.generate_ode","text":"generate_ode(eqs::DifferentialEquation, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\nFrom a set of differential equations eqs of averages, generate a Function which can be directly used in OrdinaryDiffEq. Essentially, this calls Meta.eval on the output of the build_ode function.\n\nArguments\n\n*eqs::DifferentialEquation: The set of (average) equations. *ps=[]: List of symbolic parameters, which are parsed into parameters     used in DiffEq functions. *usym=:u: The symbol used for the variable vector. *psym=:p: The symbol used for the parameter vector. *tsym=:t: The symbol used for the time parameter.\n\nOptional arguments\n\n*check_bounds::Bool=false: Choose whether the resulting function should contain     the @inbounds flag, which skips bounds checking for performance.\n\nRelated methods\n\ngenerate_ode(eqs::Vector, vs::Vector, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-correlation","page":"API","title":"Correlation functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CorrelationFunction","category":"page"},{"location":"api/#Qumulants.CorrelationFunction","page":"API","title":"Qumulants.CorrelationFunction","text":"struct CorrelationFunction\n\nType representing the two-time first-order correlation function of two operators.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Spectrum","category":"page"},{"location":"api/#Qumulants.Spectrum","page":"API","title":"Qumulants.Spectrum","text":"struct Spectrum\n\nType representing the spectrum, i.e. the Fourier transform of a CorrelationFunction in steady state.\n\nTo actually compute the spectrum at a frequency œâ, construct the type on top of a correlation function and call it with Spectrum(c)(œâ,usteady,p0).\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"initial_values","category":"page"},{"location":"api/#Qumulants.initial_values","page":"API","title":"Qumulants.initial_values","text":"initial_values(c::CorrelationFunction, u_end)\n\nFind the vector containing the correct initial values when numerical solving the time evolution for the correlation function.\n\nWhen computing the correlation function of two operators in a system that has been evolved up to a time t_end, such that its state is given by u_end, this function provides the correct initial values in the right order that can be used to solve the ordinary differential equation together with the function generated by generate_ode(c).\n\nSee also: CorrelationFunction generate_ode\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Utils","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"find_missing","category":"page"},{"location":"api/#Qumulants.find_missing","page":"API","title":"Qumulants.find_missing","text":"find_missing(rhs::Vector, vs::Vector, vs_adj=adjoint.(vs), ps=[])\n\nFor a list of expressions contained in rhs, check whether all occurring symbols are contained either in the variables given in vs. If a list of parameters ps is provided, parameters that do not occur in the list ps are also added to the list. Returns a list of missing symbols.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_symbolics","category":"page"},{"location":"api/#Qumulants.get_symbolics","page":"API","title":"Qumulants.get_symbolics","text":"get_symbolics(ex)\n\nFind all symbolic numbers occuring in ex.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_operators","category":"page"},{"location":"api/#Qumulants.get_operators","page":"API","title":"Qumulants.get_operators","text":"get_operators(::AbstractOperator)\n\nReturn a list of all BasicOperator in an expression.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"find_operators","category":"page"},{"location":"api/#Qumulants.find_operators","page":"API","title":"Qumulants.find_operators","text":"find_operators(::HilbertSpace, order; names=nothing)\n\nFind all operators that fully define a system up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"complete","category":"page"},{"location":"api/#Qumulants.complete","page":"API","title":"Qumulants.complete","text":"complete(de::DifferentialEquation)\n\nFrom a set of differential equation of averages, find all averages that are missing and derive the corresponding equations of motion.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"unique_ops","category":"page"},{"location":"api/#Qumulants.unique_ops","page":"API","title":"Qumulants.unique_ops","text":"unique_ops(ops)\n\nFor a given list of operators, return only unique ones taking into account their adjoints.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"fundamental_operators","category":"page"},{"location":"api/#Qumulants.fundamental_operators","page":"API","title":"Qumulants.fundamental_operators","text":"fundamental_operators(::HilbertSpace)\n\nReturn all fundamental operators for a given Hilbertspace. For example, a FockSpace only has one fundamental operator, Destroy.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"transition_superscript","category":"page"},{"location":"api/#Qumulants.transition_superscript","page":"API","title":"Qumulants.transition_superscript","text":"transition_superscript(::Bool)\n\nSpecify whether the indices in a Transition operator should be printed as superscript. Default is true. If set to false, the indices corresponding to the levels are printed as subscript.\n\n\n\n\n\n","category":"function"},{"location":"correlation/#Correlation-functions-and-spectra","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Two quantities that are often of interest in a system are two-time correlation functions and spectral densities. Consider, for example, two operators a and b. Their two-time correlation function is given by","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"g(ttau) = langle a(t+tau) b(t)rangle","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"As we can see, we need to take some care here since g depends on two different times. The spectral density corresponding to a and b is given by the Fourier transform,","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"S(omega) = 2textReleftint dtau e^-iomegataug(ttau)right","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"So in any case, we need to treat the two-time correlation function before we can obtain the spectrum.","category":"page"},{"location":"correlation/#Correlation-function","page":"Correlation functions and spectra","title":"Correlation function","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"In order to compute a correlation function, we first evolve a system of equations up to a time t. Then, we can derive another set of equations that describe the correlation function. This new set of equations is then evolved from time t up to a time t+tau. The correlation function is then stored in the first entry of the result. The initial state of the set of equations describing the correlation function will be determined by the state of the original system at time t.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Note, that whenever an instance of a CorrelationFunction is created, a set of equations is derived using a custom version of the complete function. Depending on the size and order of the considered system, this can take some time. An important distinction that can eventually reduce the computation time by quite a bit is whether or not the original system has been evolved up to steady state, i.e. if the system does not change its state after t. This can be controlled with the keyword argument steady_state=true when construction the CorrelationFunction.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"To clarify the usage, consider the simple case of a cavity with resonance frequency omega_mathrmc that initially has a finite number of photons inside which decay over time at a rate kappa. We want to compute the two-time correlation function of the field (first-order degree of coherence) given by","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"g(ttau) = langle a^dagger(t+tau)a(t)rangle","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Given the Hamiltonian H = omega_mathrmca^dagger a and the collapse operator a, it is easy to derive the equation","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"fracddtaua^dagger(t+tau) = (iomega_mathrmc - frackappa2)a^dagger(t+tau)","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Since a(t) is independent of tau we can simply multiply the above equation with a(t) from the right and average to obtain","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"fracddtaulangle a^dagger(t+tau) a(t)rangle = (iomega_mathrmc - frackappa2)langle a^dagger(t+tau) a(t)rangle","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Note that this is generally valid, and will lead to a system of equations that is linear in a(t). The above is the equation of motion for the correlation function g(ttau). In this very simple case we can solve it analytically and find","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"g(ttau) = langle a^dagger(t)a(t)rangle e^(iomega_mathrmc - kappa2)tau","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"This is the essential procedure with which correlation functions can be computed within Qumulants.jl. In code, the above is just:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"using Qumulants # hide\nh = FockSpace(:cavity)\na = Destroy(h,:a)\n@parameters œâc Œ∫\nH = œâc*a'*a\nhe = average(heisenberg(a'*a,H,[a];rates=[Œ∫]))\n\nc = CorrelationFunction(a', a, he)\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"When the CorrelationFunction is constructed, an additional Hilbert space is added internally which represents the system at the time t. In our case, this means that another FockSpace is added. Note that all operators involved in the correlation function are defined on the ProductSpace including this additional Hilbert space.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The equation for g(ttau) is now stored in the first entry of c.de. To solve the above numerically, we need to generate code and solve the equations numerically.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"using OrdinaryDiffEq\n\nf = generate_ode(he,(œâc,Œ∫))\nn0 = 20.0 # Initial number of photons in the cavity\nu0 = [n0]\np0 = (1,1)\nprob = ODEProblem(f,u0,(0.0,2.0),p0) # End time not in steady state\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Numerical computing the correlation function works in the same way. Note, the initial state of the correlation function depends on the final state of the system. However, in general it does not depend on all the final values of the system. The correct values can be picked out automatically using the initial_values function.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"cf = generate_ode(c, (œâc,Œ∫))\nu0_c = initial_values(c, sol.u[end])\nprob_c = ODEProblem(cf,u0_c,(0.0,10.0),p0)\nsol_c = solve(prob_c,RK4(),save_idxs=1)\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Finally, lets check our numerical solution against the analytic one obtained above:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"using Test # hide\ng_analytic(œÑ) = @. sol.u[end] * exp((im*p0[1]-0.5p0[2])*œÑ)\n@test isapprox(sol_c.u, g_analytic(sol_c.t), rtol=1e-4)","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Note, that this was a very simple case. Usually the system of equations describing the correlation function is much more complex and depends on multiple other correlation functions (see for example Spectrum of a single atom laser).","category":"page"},{"location":"correlation/#Spectrum","page":"Correlation functions and spectra","title":"Spectrum","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"There are two possible ways two compute the spectrum given a correlation function:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Solving the differential equation needed to obtain g(ttau) and taking the Fourier transform.\nTaking the (symbolic) Laplace transform of the system of equations describing a correlation function.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"On the one hand, the first approach works generally, but is computationally more intense. The second approach, on the other hand, yields a simple linear system of equations which is easy to solve, but only works when the correlation function has been computed starting from the steady state. Both methods can be easily used with Qumulants.jl.","category":"page"},{"location":"correlation/#Numerical-solution-of-g(t,\\tau)","page":"Correlation functions and spectra","title":"Numerical solution of g(ttau)","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"As mentioned above, this approach works generally, regardless of whether the system is in steady state at time t. However, it has some computational drawbacks. Additionally, the spectrum is not always well defined when not in steady state. This approach is the same as the one used in QuantumOptics.jl, and we can borrow the implemented FFT function from there:","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"œÑ = collect(range(0.0, sol_c.t[end], length=101)) # need equidistant list of times for FFT\nusing QuantumOptics.timecorrelations: correlation2spectrum\nœâ, s = correlation2spectrum(œÑ, sol_c.(œÑ))\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The spectrum obtained in this way roughly has a FWHM of Œ∫ and is based around the chosen œâc. The fact that the FWHM is not exactly Œ∫ illustrates the computation drawback: in order to obtain the correct FWHM we would have to increase the integration time by orders of magnitude. For larger system, this can be computationally expensive.","category":"page"},{"location":"correlation/#Steady-state:-using-the-Laplace-transform","page":"Correlation functions and spectra","title":"Steady state: using the Laplace transform","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"A useful property of the two-time correlation function is that, if the system is in steady state at time t, then the system of equations is linear, since b(t) can occur at most once in each product. We can therefore write any system of equations describing the correlation function as","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"fracddtau textbfy(tau) = textbfM textbfy(tau) + textbfc","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"where textbfy(tau) is the vector containing the left-hand-side of the correlation function system (g(ttau) equiv y_1(tau)). The matrix textbfM contains coefficients consisting of parameters and steady-state values, and is independent of time, and the vector textbfc includes other constants.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"We define textbfx(s) = mathcalLleft(textbfy(tau)right), i.e. textbfx(s) is the Laplace transform of textbfy(tau) with respect to tau. Applying the Laplace transform to the differential equation above, we obtain","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"(s - textbfM)textbfx(s) = textbfy(0) + fractextbfcs","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The Laplace transform is equivalent to the Fourier transform at the point s=i omega, i.e. the spectrum is given by S(omega) = 2textReleftx_1(iomega)right. Therefore, we can reduce the task to solving the equation","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Atextbfx = b","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"where A = iomega - textbfM and b = textbfy(0) + textbfc(iomega). In most cases, solving the above matrix equation is much faster than doing an additional time evolution to obtain the correlation function.","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"This approach is implemented with the Spectrum type, which performs the Laplace transform and generates a function that returns the matrix A and the vector b in numerical form depending on the steady-state values and given parameters. This can be used as follows","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"c = CorrelationFunction(a', a, he; steady_state=true) # need to specify steady state\nS = Spectrum(c,(œâc,Œ∫))\nnothing # hide","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"The above performs the Laplace transform on a symbolic level (i.e. it derives the matrix A). To actually compute the spectrum, we can do","category":"page"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"s = S(œâ,sol.u[end],p0)\nnothing # hide","category":"page"},{"location":"correlation/#Examples:","page":"Correlation functions and spectra","title":"Examples:","text":"","category":"section"},{"location":"correlation/","page":"Correlation functions and spectra","title":"Correlation functions and spectra","text":"Mollow Triplet\nSpectrum of a single atom laser","category":"page"},{"location":"examples/many-atom-laser/#Many-atom-laser","page":"Many-atom laser","title":"Many-atom laser","text":"","category":"section"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"This example describes a second order laser system consisting of N three-level atoms coupled to a single mode cavity. An auxiliary state 3rangle, which quickly decays into the upper lasing state 2rangle, is coherently pumped to achieve population inversion on the lasing transition 1rangle leftrightarrow 2rangle. The Hamiltonian of this system is given by","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"H = -Delta_c a^dagger a  - sum_i=1^N left Delta_3^i sigma_i^33  + g_i (a^dagger sigma_i^12 + asigma_i^21) + Omega_i (sigma_i^31 + sigma_i^13) right","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Including dissipative processes as, e.g. the atomic decay or photon losses through the cavity mirrors, makes it an open quantum system. In the Schr√∂dinger picture we would compute the dynamics of such open quantum systems with a density matrix rho according to a master equation (see e.g. https://docs.qojulia.org/),","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"fracddt rho = - fracihbar left H rho right + mathcalLrho","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"with mathcalLrho = fracgamma2 (2 J rho J^dagger - J^dagger J rho - rho J^dagger J) the Liouvillian superoperator in standard Lindblad form for a dissipative process with jump operator J and rate R.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"With Qumulants.jl we describe the system dynamics with averages, which are deduced from the operator equations of motion in the Heisenberg picture. In the Heisenberg picture open systems are descibed by the quantum Langevin equation. Assuming white noise, we can omit the stochastic terms of the quantum Langevin equation when computing averages. Thus we get the following equation for the time evolution of a system operator average langle O rangle (if O is not explicitly time dependent):","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"fracddt langle O rangle = fracihbar left H O right + barmathcalLO","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"The superoperator barmathcalLO is similar to the Lindblad term in the Schr√∂dinger picture, except that J and J^dagger are swapped in the first term, i.e. barmathcalLO = fracgamma2 (2 J^dagger O J - J^dagger J O - O J^dagger J), for a dissipative process with jump operator J and rate R.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"For our system we have four different dissipative processes with the jump operators a, sigma^12_i, sigma^13_i and sigma^23_i, and the corresponding decay rates kappa, Gamma^i_12, Gamma^i_13 and Gamma^i_23, respectively.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"We start by loading the needed packages.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"using Qumulants\nusing OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Then we define the symbolic parameters of the system, the Hilbertspace and the necessary operators. We define an atomic transition operator function sigma(ijk) for the transition from j rangle to i rangle of atom k. Since we only have one FockSpace we do not need to specify the Hilbertspace on which the Destroy operator acts. For the different atomic transitions, however, we need to specify this, since there is more than one NLevelSpace. This information is stored in the .aon field of each operator.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# Parameters\nN = 2 #number of atoms\nŒ∫, g, Œì23, Œì13, Œì12, Œ©, Œîc, Œî3 = parameters(\"Œ∫ g Œì_{23} Œì_{13} Œì_{12} Œ© Œî_c Œî_3\")\n\n# Hilbertspace\nhf = FockSpace(:cavity)\nha = ‚äó([NLevelSpace(Symbol(:atom,i),3) for i=1:N]...)\nh = hf ‚äó ha\n\n# Operators\na = Destroy(h,:a)\nœÉ(i,j,k) = Transition(h,Symbol(\"œÉ_{$k}\"),i,j,k+1)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Now we create the Hamiltonian and the jumps with the corresponding rates of our laser system. We assume here that all atoms are identical.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# Hamiltonian\nH = -Œîc*a'a + sum(g*(a'*œÉ(1,2,i) + a*œÉ(2,1,i)) for i=1:N) + sum(Œ©*(œÉ(3,1,i) + œÉ(1,3,i)) for i=1:N) - sum(Œî3*œÉ(3,3,i) for i=1:N)\n\n# Jumps\nJ = [a;[œÉ(1,2,i) for i=1:N];[œÉ(1,3,i) for i=1:N];[œÉ(2,3,i) for i=1:N]]\n\n# Rates\nrates = [Œ∫;[Œì12 for i=1:N];[Œì13 for i=1:N];[Œì23 for i=1:N]]\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Later we will complete the system automatically, which has the disadvantage that the equations are not ordered. Therefore we define a list of interesting operators, which we want to use later. Note that at least one operator(-product) is needed. We derive the equations for these operators, average them, and automatically complete the system of equations.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# list of operators\nops = [a'a, œÉ(2,2,1), œÉ(3,3,1)]\n\nhe = heisenberg(ops,H,J; rates=rates)\nhe_avg_ = average(he,2) #second order average\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"beginalign\nfracddt langle a^dagger  arangle  = -10 i g left( langle a^dagger  sigma_1^12rangle  + langle a^dagger  sigma_2^12rangle  right) + 10 i g left( langle a  sigma_1^21rangle  + langle a  sigma_2^21rangle  right) -10 kappa langle a^dagger  arangle  \nfracddt langle sigma_1^22rangle  = langle sigma_1^33rangle  Gamma_23 -10 langle sigma_1^22rangle  Gamma_12 + 10 i g langle a^dagger  sigma_1^12rangle  -10 i g langle a  sigma_1^21rangle  \nfracddt langle sigma_1^33rangle  = -10 i langle sigma_1^31rangle  Omega + 10 i langle sigma_1^13rangle  Omega -10 langle sigma_1^33rangle  left( Gamma_13 + Gamma_23 right)\nendalign","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"he_avg = complete(he_avg_; multithread=true) #automatically complete the system\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"To calculate the time evolution we create a Julia function which can be used by DifferentialEquations.jl to solve the set of ordinary differential equations.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# list of symbolic parameters\nps = (g, Œì23, Œì13, Œì12, Œ©, Œîc, Œî3, Œ∫)\n\n# function for DifferentialEquations.jl\nf = generate_ode(he_avg, ps)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"Finally we compute the time evolution after defining an initial state and numerical values for the parameters.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"# initial state\nu0 = zeros(ComplexF64, length(he_avg))\n\nŒì12n = 1.0\nŒì23n = 20Œì12n\nŒì13n = 2Œì12n\nŒ©n = 5Œì13n\ngn = 2Œì12n\nŒîcn = 0.0\nŒî3n = 0.0\nŒ∫n = 0.5Œì12n\n\np0 = (gn, Œì23n, Œì13n, Œì12n, Œ©n, Œîcn, Œî3n, Œ∫n)\ntend = 10.0/Œ∫n\n\nprob = ODEProblem(f,u0,(0.0,tend),p0)\nsol = solve(prob, Tsit5(), reltol=1e-8, abstol=1e-8)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"We plot the average photon number and the population inversion of the lasing transition.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"n_t = real.(getindex.(sol.u, 1))\nœÉ22m11_t = real.(2*getindex.(sol.u, 2) .+ getindex.(sol.u, 2) .-1 ) #œÉ11 + œÉ22 + œÉ33 = ùüô\n\n# Plot\np1 = plot(sol.t, n_t, xlabel=\"tŒì‚ÇÅ‚ÇÇ\", ylabel=\"‚ü®a‚Å∫a‚ü©\", legend = false)\np2 = plot(sol.t, œÉ22m11_t, xlabel=\"tŒì‚ÇÅ‚ÇÇ\", ylabel=\"‚ü®œÉ22‚ü© - ‚ü®œÉ11‚ü©\", legend = false)\nplot(p1, p2, layout=(1,2), size=(800,300))\nsavefig(\"3-level-laser.svg\") # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom laser","title":"Many-atom laser","text":"(Image: )","category":"page"},{"location":"examples/mollow/#Mollow-Triplet","page":"Mollow Triplet","title":"Mollow Triplet","text":"","category":"section"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"In the following example, we show how one can compute the resonance spectrum of a single, coherently driven atom. The Hamiltonian describing the system is given by","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"H = -Deltasigma^ee + Omegaleft(sigma^ge + sigma^egright)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"where Delta = omega_ell - omega_a is the detuning between the laser and the atomic resonance frequency and Omega is the Rabi frequency of the laser. The atom is also subject to decay at rate gamma with the damping operator sigma^ge = grangle langle e  projecting it from the excited state erangle  to its ground state grangle.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing Qumulants\nusing OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Obtaining the equations of motion for the system is simple. Note that in this case, we are not actually making any assumptions: in the special case of a single atom (even if it has more than two levels), there exists a simple mapping between the equations of motions for averages and the density operator. In our case, the density operator rho is determined by only two average values, langlesigma^egrangle = rho_eg = rho_ge^*  and langle sigma^eerangle = rho_ee = 1 - rho_gg. In other words, we are solving the master equation component-wise.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"# Hilbert space\nh = NLevelSpace(:atom, (:g,:e))\n\n# Operators\nœÉ(i,j) = Transition(h, :œÉ, i, j)\n@parameters Œî Œ© Œ≥\nH = Œî*œÉ(:e,:e) + Œ©*(œÉ(:g,:e) + œÉ(:e,:g))\nJ = [œÉ(:g,:e)]\n\n# Equations\nhe = average(heisenberg([œÉ(:e,:g),œÉ(:e,:e)], H, J; rates=[Œ≥]))","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"In order to compute the spectrum, we first need to compute the correlation function given by","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"g(tau) = langle sigma^eg(t_0+tau)sigma^ge(t_0)rangle equiv langle sigma^egsigma^ge_0rangle","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"where t_0 is any time after which the original system has reached steady state. Note, that in the second step we simplified the notation by dropping the temporal arguments. The subscript 0 indicates operators given at t_0.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"The correlation function of the system given by he can be computed as follows.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"# Correlation Function\nc = CorrelationFunction(œÉ(:e,:g), œÉ(:g,:e), he; steady_state=true)\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Note that the above actually derives another set of equations, which might take some time. Specifically, it is deriving the equation of motion for g(tau) and automatically completes the system of equation deriving the necessary equations of motion for all average values on which g(tau) depends. Here, the system of equations reads","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"c.de\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"beginalign\nfracddt langle sigma^eg  sigma_0^gerangle  = 10 i langle sigma_0^gerangle  Omega + 10 i Delta langle sigma^eg  sigma_0^gerangle  -20 i Omega langle sigma^ee  sigma_0^gerangle  -05 gamma langle sigma^eg  sigma_0^gerangle  \nfracddt langle sigma^ee  sigma_0^gerangle  = -10 i Omega langle sigma^eg  sigma_0^gerangle  + 10 i Omega langle sigma^ge  sigma_0^gerangle  -10 gamma langle sigma^ee  sigma_0^gerangle  \nfracddt langle sigma^ge  sigma_0^gerangle  = -10 i langle sigma_0^gerangle  Omega -10 i Delta langle sigma^ge  sigma_0^gerangle  + 20 i Omega langle sigma^ee  sigma_0^gerangle  -05 gamma langle sigma^ge  sigma_0^gerangle\nendalign","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"As mentioned above, to compute the time evolution of the system itself, we are effectively solving a master equation. One way to obtain the spectrum would be to solve the system in order to obtain the time evolution of the correlation function, and then take the Fourier transform. However, a computationally more efficient way is to take the Laplace transform of the correlation function directly, which yields a simple linear system of equations. Then we only have to compute a matrix inverse instead of the time evolution to obtain the spectrum.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"In the following, we will use the latter approach:","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"ps = (Œî,Œ©,Œ≥)\nS = Spectrum(c,ps)\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"mathcalF(langle œÉ^eg  œÉ_0^gerangle )(omega)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Constructing the Spectrum from the correlation function, automatically derives a matrix A and a vector b determining the set of linear equations","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"A(omega)x(omega) = b(omega)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"where the spectrum is then given by the first entry of the solution vector, S(omega)=x_1(omega).","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"To find the spectrum, we first need to compute the time evolution of the system up to steady state.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"f = generate_ode(he,ps)\n\np0 = (0.0,2.0,1.0)\nu0 = zeros(ComplexF64, 2)\nprob = ODEProblem(f,u0,(0.0,20.0),p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"plot(sol, vars=((x,y)->(x,real(y)), 0, 2),xlabel=\"Œ≥t\", label=\"Excited state population\")\nsavefig(\"mollow-1.svg\") # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"(Image: svg)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"Now, solving the linear system to obtain the spectrum can simply be done by calling the instance at a range of frequencies, and providing the proper steady-state values and numerical parameters.","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"œâ = range(-6pi,6pi,length=1001)\ns = S(œâ,sol.u[end],p0)\nplot(œâ,s,xlabel=\"œâ - œâ‚Ñì\",label=\"Resonance spectrum\")\nsavefig(\"mollow-2.svg\") # hide","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"(Image: svg)","category":"page"},{"location":"examples/mollow/","page":"Mollow Triplet","title":"Mollow Triplet","text":"The resulting spectrum shows a prominent peak at the resonance point (omega=omega_ell=omega_a), but also two more peaks around omega approx pm Omega^2gamma. These two resonances originate from the dressed states. These three peaks are called Mollow Triplet.","category":"page"},{"location":"examples/single-atom-laser-spectrum/#Spectrum-of-a-single-atom-laser","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"","category":"section"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"In this example, we will compute the spectrum of the single-atom laser, which is also shown in the Tutorial. The Hamitlonian of the system is","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"H = Delta a^dagger a + gleft(a^dagger sigma^ge + asigma^egright)","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"where Delta = omega_mathrmc - omega_mathrma is the detuning between the cavity and the atomic resonance frequency, respectively. The cavity loses photons at a rate kappa, and the atom is subject to spontaneous emission with a rate gamma. Additionally, the atom is incoherently driven with a rate nu, such that it can provide lasing gain to the system. We start, by specifying this model.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing Qumulants\nusing OrdinaryDiffEq\nusing Plots\n\n# Define parameters\n@parameters Œî g Œ≥ Œ∫ ŒΩ\n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf ‚äó ha\n\n# Define the fundamental operators\na = Destroy(h,:a)\ns = Transition(h,:œÉ,:g,:e)\n\n# Hamiltonian\nH = Œî*a'*a + g*(a'*s + a*s')\n\n# Collapse operators\nJ = [a,s,s']\nrates = [Œ∫,Œ≥,ŒΩ]\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"The first equation we want to derive is that for the average photon number langle a^dagger a rangle.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Derive equation for average photon number\nhe_n = average(heisenberg(a'*a,H,J;rates=rates), 2)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"The remaining equations will be computed automatically using the complete function. However, we want to exclude terms such as langle a rangle since these are phase-dependent and therefore 0 in our phase-invariant system. To this end, we provide a custom filter function to complete. This function should return true, if the given average should be included, and false if it should be excluded (just like Julia's native filter function requires). We write a small function phi that computes the phase of an average, such that phi(a) = -1, phi(a^dagger) = 1, and phi(a^dagger a) = phi(a) + phi(a^dagger) = 0. Similarly, we want to have phi(sigma^eg)=1=-phi(sigma^ge), and phi(sigma^ee)=0. An average of an operator x is then said to be phase invariant if phi(x)=0.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Custom filter function -- include only phase-invaraint terms\nœï(x) = 0\nœï(::Destroy) = -1\nœï(::Create) = 1\nfunction œï(t::Transition)\n    if (t.i==:e && t.j==:g)\n        1\n    elseif (t.i==:g && t.j==:e)\n        -1\n    else\n        0\n    end\nend\nœï(avg::Average) = œï(avg.operator)\nfunction œï(t::OperatorTerm)\n    @assert t.f === (*)\n    p = 0\n    for arg in t.arguments\n        p += œï(arg)\n    end\n    return p\nend\nphase_invariant(x) = iszero(œï(x))\n\n# Complete equations\nhe = complete(he_n;filter_func=phase_invariant)","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"In order to compute the spectrum, we first compute the correlation function g(tau) = langle a^dagger(t_0 + tau) a(t_0)rangle equiv langle a^dagger a_0rangle","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Note that the CorrelationFunction finds the equation for g(tau) and then completes the system of equations by using its own version of the complete function. We can also provide the same custom filter function as before to skip over terms that are not phase-invariant. Similarly, setting the keyword steady_state=true, we tell the function not to derive equations of motion for operators that do not depend on tau, but only on t_0 (if t_0 is in steady state, these values do not change with tau).","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Correlation function\nc = CorrelationFunction(a', a, he; steady_state=true, filter_func=phase_invariant)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"langle a^dagger a_0rangle","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"As we can see, there are only two equations necessary to obtain the correlation function:","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"c.de\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"beginalign fracddt langle a^dagger a_0rangle = 10 i g langle sigma^eg a_0rangle + 10 i Delta langle a^dagger a_0rangle -05 kappa langle a^dagger a_0rangle \nfracddt langle sigma^eg a_0rangle = 10 i g langle a^dagger a_0rangle -05 gamma langle sigma^eg a_0rangle -05 nu langle sigma^eg a_0rangle -20 i langle sigma^eerangle g langle a^dagger a_0rangle\nendalign","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"The spectrum can now be computed by solving the above system of equations and then taking the Fourier transform, or by taking the Fourier transform directly, which is done by constructing an instance of the Spectrum type. Here, we will compare both approaches.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"In any case, we need to compute the steady state of the system numerically.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Numerical solution\nps = (Œî, g, Œ≥, Œ∫, ŒΩ)\nf = generate_ode(he,ps)\nu0 = zeros(ComplexF64, length(he))\np0 = (1.0, 1.5, 0.25, 1, 4)\nprob = ODEProblem(f,u0,(0.0,10.0),p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Now, we can compute the time evolution of the correlation function in a similar way. initial_valses!!!!","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Time evolution of correlation function\ncf = generate_ode(c,ps)\nu0_c = initial_values(c,sol.u[end])\np0_c = (p0..., sol.u[end]...)\nprob_c = ODEProblem(cf,u0_c,(0.0,500.0),p0_c)\nsol_c = solve(prob_c,RK4(),save_idxs=1)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Finally, we borrow the FFT function from QuantumOptics.jl and compute the spectrum from the solution. Note that this requires an equidistant list of times, and we therefore interpolate the solution from the differential equation.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Interpolate solution\nœÑ = range(0.0, sol_c.t[end], length=15001)\ncorr = sol_c.(œÑ)\n\n# Compute spectrum\nusing QuantumOptics.timecorrelations: correlation2spectrum\nœâ, s_fft = correlation2spectrum(œÑ, corr)\nnothing # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"Now, in order to compare we also compute the spectrum by constructing it directly from the correlation function and plot the results.","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"# Spectrum\nS = Spectrum(c,ps)\ns_laplace = S(œâ,sol.u[end],p0)\nnothing # hide\n\nplot(œâ, s_fft, label=\"Spectrum (FFT)\", xlabel=\"œâ\")\nplot!(œâ, s_laplace, label=\"Spectrum (Laplace)\")\nxlims!(-3,3)\nsavefig(\"laser-spectrum.svg\") # hide","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"(Image: svg)","category":"page"},{"location":"examples/single-atom-laser-spectrum/","page":"Spectrum of a single-atom laser","title":"Spectrum of a single-atom laser","text":"As expected, both methods yield exactly the same spectrum. The difference is just in the method used, with the Laplace transform having a computational advantage.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Qumulants.jl offers a practical approach to the application of the generalized cumulant expansion method in Quantum Optics: operators are often represented by matrices on a Hilbert space, where a suitable basis has been chosen. These matrices can quickly become so large that they can no longer be stored. On a more abstract level, however, operators form a noncommutative alebgra that follows fundamental commutation relations. This is where Qumulants.jl comes in. The basic working principle boils down to the following steps:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The model (Hamiltonian) is specified.\nEquations of motion (Heisenberg equations) are symbolically derived for the system operators by using their fundamental commutation relations.\nThen follows the key step: the equations of motion for the noncommutative operators are averaged and truncated at a specified order neglecting higher-order quantum correlations using the generalized cumulant expansion method. This results in a closed set of c-number ordinary differential equations.\nFinally, the symbolic system of equations can be turned into a native Julia function which is directly usable in the DifferentialEquations.jl framework. This makes it straightforward to obtain a solution of the time dynamics of a system.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Qumulants.jl is not officially released (yet) and so has to be installed directly from GitHub. This can be done with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"|pkg> add https://github.com/david-pl/Qumulants.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For a full list of functions, check out the API.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The basic usage is probably best illustrated with a brief example. In the following, we solve a simple model for a single-atom laser.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We start by loading the package, defining some symbolic parameters and the photonic annihilation operator a as well as the atomic lowering operator s. This allows us to quickly write down the Hamiltonian and the collapse operators of the system with their corresponding decay rates.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing Qumulants\n\n# Define parameters\n@parameters Œî g Œ≥ Œ∫ ŒΩ\n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf ‚äó ha\n\n# Define the fundamental operators\na = Destroy(h,:a)\ns = Transition(h,:œÉ,:g,:e)\n\n# Hamiltonian\nH = Œî*a'*a + g*(a'*s + a*s')\n\n# Collapse operators\nJ = [a,s,s']\nrates = [Œ∫,Œ≥,ŒΩ]\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, we define a list of operators of which we want to compute the Heisenberg equations. We will only consider products of two operators. This is because later we will compute the dynamics of the system up to second order.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Derive a set of Heisenberg equations\nops = [a'*a,s'*s,a'*s]\nhe = heisenberg(ops,H,J;rates=rates)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The equations derived above are differential equations for operators. In order to convert them to c-number equations, we need to average over them. To obtain a closed set of equations, we expand higher-order products to second order.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Average the above equations and expand to second order\nhe_avg = average(he,2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first-order contributions are always zero and can therefore be neglected. You can try adding a and s to the list of operators ops in order to see that yourself. Or, even more conveniently, you can use complete(he_avg), which will automatically find all missing averages and compute the corresponding equations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, though, we will proceed by finding the missing averages, and neglecting them as zero using the substitute function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Find the missing averages\nmissed = find_missing(he_avg)\n\n# Substitute them as zero\nsubs = Dict(missed .=> 0)\nhe_nophase = simplify_constants(substitute(he_avg, subs))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we can generate Julia code from the above set of equations which can be solved directly using the OrdinaryDiffEq.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate a Julia function that to solve numerically\np = (Œî, g, Œ≥, Œ∫, ŒΩ)\nf = generate_ode(he_nophase,p)\n\n# Solve the system using the OrdinaryDiffEq package\nusing OrdinaryDiffEq\nu0 = zeros(ComplexF64,length(ops))\np0 = (0, 1.5, 0.25, 1, 4)\nprob = ODEProblem(f,u0,(0.0,10.0),p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The photon number of our laser and the excited state population of the atom are now stored in the first two fields of sol.u.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nn = real.(getindex.(sol.u, 1))\npe = real.(getindex.(sol.u, 2))\nplot(sol.t, n, label=\"Photon number\", xlabel=\"t\")\nplot!(sol.t, pe, label=\"Excited state population\")\nsavefig(\"tutorial.svg\") # hide\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Photon number and excited state population)","category":"page"}]
}
