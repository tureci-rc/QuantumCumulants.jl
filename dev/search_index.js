var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#API:-Hilbert-Spaces","page":"API","title":"Hilbert Spaces","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HilbertSpace","category":"page"},{"location":"api/#Qumulants.HilbertSpace","page":"API","title":"Qumulants.HilbertSpace","text":"HilbertSpace\n\nAbstract type for representing Hilbert spaces.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"ProductSpace","category":"page"},{"location":"api/#Qumulants.ProductSpace","page":"API","title":"Qumulants.ProductSpace","text":"ProductSpace <: HilbertSpace\n\nStores a composite HilbertSpace consisting of multiple subspaces. Generally created by computing the tensor product âŠ— of subspaces.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"FockSpace","category":"page"},{"location":"api/#Qumulants.FockSpace","page":"API","title":"Qumulants.FockSpace","text":"FockSpace <: HilbertSpace\n\nHilbertSpace defining a Fock space for bosonic operators. See also: Destroy, Create\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"NLevelSpace","category":"page"},{"location":"api/#Qumulants.NLevelSpace","page":"API","title":"Qumulants.NLevelSpace","text":"NLevelSpace <: HilbertSpace\nNLevelSpace(name::Symbol,levels,GS=1)\n\nDefine a HilbertSpace for an object consisting of N discrete energy levels. The given levels must be an integer specifying the number of levels, or an iterable collection of levels. The argument GS specifies which state should be treated as ground state and is rewritten using population conservation during simplification. See also: Transition\n\nExamples:\n\njulia> ha = NLevelSpace(:a,3)\nâ„‹(a)\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nâ„‹(a)\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"âŠ—","category":"page"},{"location":"api/#Qumulants.:âŠ—","page":"API","title":"Qumulants.:âŠ—","text":"âŠ—(spaces::HilbertSpace...)\n\nCreate a ProductSpace consisting of multiple subspaces.\n\nExamples\n\njulia> hf = FockSpace(:f)\nâ„‹(f)\n\njulia> ha = NLevelSpace(:a,2)\nâ„‹(a)\n\njulia> h = hfâŠ—ha\nâ„‹(f) âŠ— â„‹(a)\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Operators","page":"API","title":"Operators","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractOperator","category":"page"},{"location":"api/#Qumulants.AbstractOperator","page":"API","title":"Qumulants.AbstractOperator","text":"AbstractOperator\n\nAbstract type representing any expression involving operators.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"BasicOperator","category":"page"},{"location":"api/#Qumulants.BasicOperator","page":"API","title":"Qumulants.BasicOperator","text":"BasicOperator <: AbstractOperator\n\nAbstract type representing fundamental operator types.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"OperatorTerm","category":"page"},{"location":"api/#Qumulants.OperatorTerm","page":"API","title":"Qumulants.OperatorTerm","text":"OperatorTerm <: AbstractOperator\n\nSymbolic expression tree consisting of AbstractOperator and Number arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Destroy","category":"page"},{"location":"api/#Qumulants.Destroy","page":"API","title":"Qumulants.Destroy","text":"Destroy <: BasicOperator\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator annihilation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Create","category":"page"},{"location":"api/#Qumulants.Create","page":"API","title":"Qumulants.Create","text":"Create <: BasicOperator\n\nBosonic operator on a FockSpace representing the quantum harmonic oscillator creation operator.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Transition","category":"page"},{"location":"api/#Qumulants.Transition","page":"API","title":"Qumulants.Transition","text":"Transition <: BasicOperator\nTransition(h::NLevelSpace,name::Symbol,i,j)\n\nFundamental operator defining a transition from level j to level i on a NLevelSpace. The notation corresponds to Dirac notation, i.e. the above is equivalent to |iâŸ©âŸ¨j|.\n\nExamples\n\njulia> ha = NLevelSpace(:a,(:g,:e))\nâ„‹(a)\n\njulia> Ïƒ = Transition(ha,:Ïƒ,:g,:e)\nÏƒge\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Heisenberg","page":"API","title":"Heisenberg","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"heisenberg","category":"page"},{"location":"api/#Qumulants.heisenberg","page":"API","title":"Qumulants.heisenberg","text":"heisenberg(ops::Vector,H::AbstractOperator)\nheisenberg(op::AbstractOperator,H::AbstractOperator)\n\nCompute a set of Heisenberg equations of the operators in ops under the Hamiltonian H.\n\n\n\n\n\nheisenberg(ops::Vector,H::AbstractOperator,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\nheisenberg(op::AbstractOperator,H::AbstractOperator,J::Vector;\n        Jdagger::Vector=adjoint.(J),rates=ones(length(J)))\n\nCompute the set of equations for the operators in ops under the Hamiltonian H and with loss operators contained in J. The resulting equation is equivalent to the Quantum-Langevin equation where noise is neglected.\n\nArguments\n\n*ops::Vector{<:AbstractVector}: The operators of which the equations are to be computed. *H::AbstractOperatr: The Hamiltonian describing the reversible dynamics of the     system. *J::Vector{<:AbstractOperator}: A vector containing the collapse operators of     the system. A term of the form     sum_i J_i^dagger O J_i - frac12left(J_i^dagger J_i O + OJ_i^dagger J_iright)     is added to the Heisenberg equation.\n\nOptional argumentes\n\n*Jdagger::Vector=adjoint.(J): Vector containing the hermitian conjugates of     the collapse operators. *rates=ones(length(J)): Decay rates corresponding to the collapse operators in J.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"commutator","category":"page"},{"location":"api/#Qumulants.commutator","page":"API","title":"Qumulants.commutator","text":"commutator(a,b; simplify=true, kwargs...)\n\nComputes the commutator a*b - b*a of a and b. If simplify is true, the result is simplified using the simplify_operators function. Further keyword arguments are passed to simplification.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"acts_on","category":"page"},{"location":"api/#Qumulants.acts_on","page":"API","title":"Qumulants.acts_on","text":"acts_on(op::AbstractOperator)\n\nShows on which Hilbert space op acts. For BasicOperator types, this returns an Integer, whereas for a OperatorTerm it returns a Vector{Int} whose entries specify all subspaces on which the expression acts.\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Differential-equations","page":"API","title":"Differential Equations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"AbstractEquation","category":"page"},{"location":"api/#Qumulants.AbstractEquation","page":"API","title":"Qumulants.AbstractEquation","text":"Abstract type for equations.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"DifferentialEquation","category":"page"},{"location":"api/#Qumulants.DifferentialEquation","page":"API","title":"Qumulants.DifferentialEquation","text":"DifferentialEquation{LHS,RHS,H,J,R} <: AbstractEquation{LHS,RHS}\nDifferentialEquation(lhs,rhs,H,J,rates)\n\nType defining a system of differential equations, where lhs is a vector of derivatives and rhs is a vector of expressions. In addition, it keeps track of the Hamiltonian, the collapse operators and the corresponding decay rates of the system.\n\nFields\n\n*lhs: Vector of operators or averages of which the derivatives are taken. *rhs: Vector of expressions to which the derivatives are equal. *hamiltonian: Operator defining the system Hamiltonian. *jumps: Vector of operators specifying the decay processes. *rates: Decay rates corresponding to the jumps.\n\n\n\n\n\n","category":"type"},{"location":"api/#API:-Symbolic-numbers","page":"API","title":"Symbolic Numbers","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"SymbolicNumber","category":"page"},{"location":"api/#Qumulants.SymbolicNumber","page":"API","title":"Qumulants.SymbolicNumber","text":"SymbolicNumber <: Number\n\nAbstract type for all symbolic numbers, i.e. Parameter, Average and corresponding expression trees.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"NumberTerm","category":"page"},{"location":"api/#Qumulants.NumberTerm","page":"API","title":"Qumulants.NumberTerm","text":"NumberTerm <: SymbolicNumber\n\nExpression tree consisting of SymbolicNumber variables.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"Parameter","category":"page"},{"location":"api/#Qumulants.Parameter","page":"API","title":"Qumulants.Parameter","text":"Parameter <: SymbolicNumber\n\nA parameter represented as a symbolic. See also: parameters, @parameters\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"parameters","category":"page"},{"location":"api/#Qumulants.parameters","page":"API","title":"Qumulants.parameters","text":"parameters(symbols::Symbol...)\nparamters(s::String)\n\nCreate symbolic parameters.\n\nExpamples\n\njulia> ps = parameters(:a, :b)\n(a, b)\n\njulia> parameters(\"a b\") == ps\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"@parameters","category":"page"},{"location":"api/#Qumulants.@parameters","page":"API","title":"Qumulants.@parameters","text":"@parameters(ps...)\n\nConvenience macro to quickly define symbolic parameters.\n\nExamples\n\njulia> @parameters Ï‰ Îº\n(Ï‰, Îº)\n\n\n\n\n\n","category":"macro"},{"location":"api/#API:-Simplify","page":"API","title":"Simplification","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"simplify_operators","category":"page"},{"location":"api/#Qumulants.simplify_operators","page":"API","title":"Qumulants.simplify_operators","text":"simplify_operators(op::AbstractOperator; rewriter=default_operator_simplifier(), kwargs...)\n\nSimplify an operator through standard algebraic rewriting, as well as using fundamental commutation relations.\n\nArguments\n\n===========\n\nop: The operator expression to be simplified.\nrewriter: The rewriter used.\nkwargs: Further arguments passed to SymbolicUtils.simplify.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"simplify_constants","category":"page"},{"location":"api/#Qumulants.simplify_constants","page":"API","title":"Qumulants.simplify_constants","text":"simplify_constants(t::NumberTerm;kwargs...)\n\nStandard simplification for SymbolicNumber types. Converts to a SymbolicUtils expression and uses its standard simplification routines for symbolic number variables.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"expand","category":"page"},{"location":"api/#Qumulants.expand","page":"API","title":"Qumulants.expand","text":"expand(ex; rewriter=defualt_expand_simplifier(), kwargs...)\n\nSimple wrapper around SymbolicUtils.simplify that uses a rewriter such that expressions are expanded.\n\nArguments\n\n===========\n\nex: The expression to be expanded.\nrewriter: The used rewriter.\nkwargs: Further arguments passed to SymbolicUtils.simplify.\n\nExamples\n\njulia> @parameters p q r\n(p, q, r)\n\njulia> ex = p*(q+r) + (q+p)*(r+q)\n((p*(q+r))+((q+p)*(r+q)))\n\njulia> expand(ex)\n((p*q)+(p*r)+(q*r)+(p*r)+(q*q)+(p*q))\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"substitute","category":"page"},{"location":"api/#Qumulants.substitute","page":"API","title":"Qumulants.substitute","text":"substitute(arg, subs; simplify=true)\n\nSubstitute the symbolic argument, i.e. any subtype to AbstractOperator or SymbolicNumber according to the substitutions stored in a Dict. Also works on DifferentialEquation. If simplify=true, the output is simplified.\n\nExamples\n\njulia> @parameters p\n(p,)\n\njulia> substitute(p, Dict(p=>2))\n2\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Average","page":"API","title":"Average","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Average","category":"page"},{"location":"api/#Qumulants.Average","page":"API","title":"Qumulants.Average","text":"Average <: SymbolicNumber\n\nSymbolic number representing the average over an operator. See also: average\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"average","category":"page"},{"location":"api/#Qumulants.average","page":"API","title":"Qumulants.average","text":"average(::AbstractOperator)\naverage(::AbstractOperator,order::Int)\n\nCompute the average of an operator. If order is given, the cumulant_expansion up to that order is computed immediately.\n\n\n\n\n\naverage(::DifferentialEquation;multithread=false)\naverage(::DifferentialEquation,order::Int;multithread=false)\n\nCompute the average of a DifferentialEquation (or a set of equations). Returns a DifferentialEquation with containing the corresponding equations for averages. If order is specified, the cumulant_expansion up to that order is computed immediately. The keyword multithread specifies whether the averaging (and cumulant_expansion) should be parallelized (defaults to false).\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"cumulant_expansion","category":"page"},{"location":"api/#Qumulants.cumulant_expansion","page":"API","title":"Qumulants.cumulant_expansion","text":"cumulant_expansion(avg, order::Int)\n\nFor an Average of an operator, expand it in terms of moments up to order neglecting their joint cumulant.\n\nSee also: https://en.wikipedia.org/wiki/Cumulant#Joint_cumulants\n\nExamples\n\njulia> avg = average(a*b)\nâŸ¨a*bâŸ©\n\njulia> cumulant_expansion(avg,1)\n(âŸ¨aâŸ©*âŸ¨bâŸ©)\n\njulia> avg = average(a*b*c)\nâŸ¨a*b*câŸ©\n\njulia> cumulant_expansion(avg,2)\n((âŸ¨a*bâŸ©*âŸ¨câŸ©)+(âŸ¨a*câŸ©*âŸ¨bâŸ©)+(âŸ¨aâŸ©*âŸ¨b*câŸ©)+(-2*âŸ¨aâŸ©*âŸ¨bâŸ©*âŸ¨câŸ©))\n\nOptional arguments\n\n*simplify=true: Specify whether the result should be simplified. *kwargs...: Further keyword arguments being passed to simplify_constants\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"cumulant","category":"page"},{"location":"api/#Qumulants.cumulant","page":"API","title":"Qumulants.cumulant","text":"cumulant(x,n=get_order(x);simplify=true,kwargs...)\n\nCompute the nth cumulant of x (either an operator or an average). The output is simplified when simplify=true. Further keyword arguments are passed on to simplification.\n\nExamples\n\njulia> cumulant(a)\nâŸ¨aâŸ©\n\njulia> cumulant(a*b)\n(âŸ¨a*bâŸ©+(-1*âŸ¨aâŸ©*âŸ¨bâŸ©))\n\njulia> cumulant(a*b,1)\nâŸ¨a*bâŸ©\n\njulia> cumulant(a*b,3)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_order","category":"page"},{"location":"api/#Qumulants.get_order","page":"API","title":"Qumulants.get_order","text":"get_order(arg)\n\nCompute the order of a given argument. This is the order used to decide whether something should be expanded using a cumulant_expansion method.\n\nExamples\n\njulia> get_order(a)\n1\n\njulia> get_order(a*b)\n2\n\njulia> get_order(1)\n0\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-DiffEq","page":"API","title":"Function generation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"build_ode","category":"page"},{"location":"api/#Qumulants.build_ode","page":"API","title":"Qumulants.build_ode","text":"build_ode(rhs::Vector, vs::Vector, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\nFrom a set of equations contained in eqs, generate a Meta.Expr containing the code for a function which can be directly passed to OrdinaryDiffEq in order to solve it. The variable vector u corresponds to the symbols provided in vs.\n\nArguments\n\n*eqs::Vector: The vector containing the right-hand side of equations. *vs::Vector: The vector containing the left-hand side of equations. *ps=[]: List of (symbolic) parameters, which are parsed into parameters     used in DiffEq functions. *usym=:u: The symbol used for the variable vector. *psym=:p: The symbol used for the parameter vector. *tsym=:t: The symbol used for the time parameter.\n\nOptional arguments\n\n*check_bounds::Bool=false: Choose whether the resulting function should contain     the @inbounds flag, which skips bounds checking for performance.\n\n\n\n\n\nbuild_ode(eqs::DifferentialEquation, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\nFrom a set of differential equationseqs of averages, generate a Meta.Expr containing the code for a function which can be directly passed to OrdinaryDiffEq in order to solve it.\n\nArguments\n\n*eqs::DifferentialEquation: The set of (average) equations. *ps=[]: List of symbolic parameters, which are parsed into parameters     used in DiffEq functions. *usym=:u: The symbol used for the variable vector. *psym=:p: The symbol used for the parameter vector. *tsym=:t: The symbol used for the time parameter.\n\nOptional arguments\n\n*check_bounds::Bool=false: Choose whether the resulting function should contain     the @inbounds flag, which skips bounds checking for performance.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"generate_ode","category":"page"},{"location":"api/#Qumulants.generate_ode","page":"API","title":"Qumulants.generate_ode","text":"generate_ode(eqs::DifferentialEquation, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\nFrom a set of differential equations eqs of averages, generate a Function which can be directly used in OrdinaryDiffEq. Essentially, this calls Meta.eval on the output of the build_ode function.\n\nArguments\n\n*eqs::DifferentialEquation: The set of (average) equations. *ps=[]: List of symbolic parameters, which are parsed into parameters     used in DiffEq functions. *usym=:u: The symbol used for the variable vector. *psym=:p: The symbol used for the parameter vector. *tsym=:t: The symbol used for the time parameter.\n\nOptional arguments\n\n*check_bounds::Bool=false: Choose whether the resulting function should contain     the @inbounds flag, which skips bounds checking for performance.\n\nRelated methods\n\ngenerate_ode(eqs::Vector, vs::Vector, ps=[], usym=:u,\n            psym=:p, tsym=:t; set_unknowns_zero::Bool=false, check_bounds::Bool=false)\n\n\n\n\n\n","category":"function"},{"location":"api/#API:-Utils","page":"API","title":"Utility functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"find_missing","category":"page"},{"location":"api/#Qumulants.find_missing","page":"API","title":"Qumulants.find_missing","text":"find_missing(rhs::Vector, vs::Vector, vs_adj=adjoint.(vs), ps=[])\n\nFor a list of expressions contained in rhs, check whether all occurring symbols are contained either in the variables given in vs. If a list of parameters ps is provided, parameters that do not occur in the list ps are also added to the list. Returns a list of missing symbols.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_symbolics","category":"page"},{"location":"api/#Qumulants.get_symbolics","page":"API","title":"Qumulants.get_symbolics","text":"get_symbolics(ex)\n\nFind all symbolic numbers occuring in ex.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"get_operators","category":"page"},{"location":"api/#Qumulants.get_operators","page":"API","title":"Qumulants.get_operators","text":"get_operators(::AbstractOperator)\n\nReturn a list of all BasicOperator in an expression.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"find_operators","category":"page"},{"location":"api/#Qumulants.find_operators","page":"API","title":"Qumulants.find_operators","text":"find_operators(::HilbertSpace, order; names=nothing)\n\nFind all operators that fully define a system up to the given order.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"complete","category":"page"},{"location":"api/#Qumulants.complete","page":"API","title":"Qumulants.complete","text":"complete(de::DifferentialEquation)\n\nFrom a set of differential equation of averages, find all averages that are missing and derive the corresponding equations of motion.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"unique_ops","category":"page"},{"location":"api/#Qumulants.unique_ops","page":"API","title":"Qumulants.unique_ops","text":"unique_ops(ops)\n\nFor a given list of operators, return only unique ones taking into account their adjoints.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"fundamental_operators","category":"page"},{"location":"api/#Qumulants.fundamental_operators","page":"API","title":"Qumulants.fundamental_operators","text":"fundamental_operators(::HilbertSpace)\n\nReturn all fundamental operators for a given Hilbertspace. For example, a FockSpace only has one fundamental operator, Destroy.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"transition_superscript","category":"page"},{"location":"api/#Qumulants.transition_superscript","page":"API","title":"Qumulants.transition_superscript","text":"transition_superscript(::Bool)\n\nSpecify whether the indices in a Transition operator should be printed as superscript. Default is true. If set to false, the indices corresponding to the levels are printed as subscript.\n\n\n\n\n\n","category":"function"},{"location":"examples/many-atom-laser/#Many-atom-level-laser","page":"Many-atom level laser","title":"Many-atom level laser","text":"","category":"section"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"This example describes a second order laser system consisting of N three-level atoms coupled to a single mode cavity. An auxiliary state 3rangle, which quickly decays into the upper lasing state 2rangle, is coherently pumped to achieve population inversion on the lasing transition 1rangle leftrightarrow 2rangle. The Hamiltonian of this system is given by","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"H = -Delta_c a^dagger a  - sum_i=1^N left Delta_3^i sigma_i^33  + g_i (a^dagger sigma_i^12 + asigma_i^21) + Omega_i (sigma_i^31 + sigma_i^13) right","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"Including dissipative processes as, e.g. the atomic decay or photon losses through the cavity mirrors, makes it an open quantum system. In the SchrÃ¶dinger picture we would compute the dynamics of such open quantum systems with a density matrix rho according to a master equation (see e.g. https://docs.qojulia.org/),","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"fracddt rho = - fracihbar left H rho right + mathcalLrho","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"with mathcalLrho = fracgamma2 (2 J rho J^dagger - J^dagger J rho - rho J^dagger J) the Liouvillian superoperator in standard Lindblad form for a dissipative process with jump operator J and rate R.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"With Qumulants.jl we describe the system dynamics with averages, which are deduced from the operator equations of motion in the Heisenberg picture. In the Heisenberg picture open systems are descibed by the quantum Langevin equation. Assuming white noise, we can omit the stochastic terms of the quantum Langevin equation when computing averages. Thus we get the following equation for the time evolution of a system operator average langle O rangle (if O is not explicitly time dependent):","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"fracddt langle O rangle = fracihbar left H O right + barmathcalLO","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"The superoperator barmathcalLO is similar to the Lindblad term in the SchrÃ¶dinger picture, except that J and J^dagger are swapped in the first term, i.e. barmathcalLO = fracgamma2 (2 J^dagger O J - J^dagger J O - O J^dagger J), for a dissipative process with jump operator J and rate R.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"For our system we have four different dissipative processes with the jump operators a, sigma^12_i, sigma^13_i and sigma^23_i, and the corresponding decay rates kappa, Gamma^i_12, Gamma^i_13 and Gamma^i_23, respectively.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"We start by loading the needed packages.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"using Qumulants\nusing OrdinaryDiffEq\nusing Plots","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"Then we define the symbolic parameters of the system, the Hilbertspace and the necessary operators. We define an atomic transition operator function sigma(ijk) for the transition from j rangle to i rangle of atom k. Since we only have one FockSpace we do not need to specify the Hilbertspace on which the Destroy operator acts. For the different atomic transitions, however, we need to specify this, since there is more than one NLevelSpace. This information is stored in the .aon field of each operator.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"# Parameters\nN = 2 #number of atoms\nÎº, g, Î“23, Î“13, Î“12, Î©, Î”c, Î”3 = parameters(\"Îº g Î“_{23} Î“_{13} Î“_{12} Î© Î”_c Î”_3\")\n\n# Hilbertspace\nhf = FockSpace(:cavity)\nha = âŠ—([NLevelSpace(Symbol(:atom,i),3) for i=1:N]...)\nh = hf âŠ— ha\n\n# Operators\na = Destroy(h,:a)\nÏƒ(i,j,k) = Transition(h,Symbol(\"Ïƒ_{$k}\"),i,j,k+1)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"Now we create the Hamiltonian and the jumps with the corresponding rates of our laser system. We assume here that all atoms are identical.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"# Hamiltonian\nH = -Î”c*a'a + sum(g*(a'*Ïƒ(1,2,i) + a*Ïƒ(2,1,i)) for i=1:N) + sum(Î©*(Ïƒ(3,1,i) + Ïƒ(1,3,i)) for i=1:N) - sum(Î”3*Ïƒ(3,3,i) for i=1:N)\n\n# Jumps\nJ = [a;[Ïƒ(1,2,i) for i=1:N];[Ïƒ(1,3,i) for i=1:N];[Ïƒ(2,3,i) for i=1:N]]\n\n# Rates\nrates = [Îº;[Î“12 for i=1:N];[Î“13 for i=1:N];[Î“23 for i=1:N]]\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"Later we will complete the system automatically, which has the disadvantage that the equations are not ordered. Therefore we define a list of interesting operators, which we want to use later. Note that at least one operator(-product) is needed. We derive the equations for these operators, average them, and automatically complete the system of equations.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"# list of operators\nops = [a'a, Ïƒ(2,2,1), Ïƒ(3,3,1)]\n\nhe = heisenberg(ops,H,J; rates=rates)\nhe_avg_ = average(he,2) #second order average\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"beginalign\nfracddt langle a^dagger  arangle  = -10 i g left( langle a^dagger  sigma_1^12rangle  + langle a^dagger  sigma_2^12rangle  right) + 10 i g left( langle a  sigma_1^21rangle  + langle a  sigma_2^21rangle  right) -10 kappa langle a^dagger  arangle  \nfracddt langle sigma_1^22rangle  = langle sigma_1^33rangle  Gamma_23 -10 langle sigma_1^22rangle  Gamma_12 + 10 i g langle a^dagger  sigma_1^12rangle  -10 i g langle a  sigma_1^21rangle  \nfracddt langle sigma_1^33rangle  = -10 i langle sigma_1^31rangle  Omega + 10 i langle sigma_1^13rangle  Omega -10 langle sigma_1^33rangle  left( Gamma_13 + Gamma_23 right)\nendalign","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"he_avg = complete(he_avg_; multithread=true) #automatically complete the system\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"To calculate the time evolution we create a Julia function which can be used by DifferentialEquations.jl to solve the set of ordinary differential equations.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"# list of symbolic parameters\nps = (g, Î“23, Î“13, Î“12, Î©, Î”c, Î”3, Îº)\n\n# function for DifferentialEquations.jl\nf = generate_ode(he_avg, ps)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"Finally we compute the time evolution after defining an initial state and numerical values for the parameters.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"# initial state\nu0 = zeros(ComplexF64, length(he_avg))\n\nÎ“12n = 1.0\nÎ“23n = 20Î“12n\nÎ“13n = 2Î“12n\nÎ©n = 5Î“13n\ngn = 2Î“12n\nÎ”cn = 0.0\nÎ”3n = 0.0\nÎºn = 0.5Î“12n\n\np0 = (gn, Î“23n, Î“13n, Î“12n, Î©n, Î”cn, Î”3n, Îºn)\ntend = 10.0/Îºn\n\nprob = ODEProblem(f,u0,(0.0,tend),p0)\nsol = solve(prob, Tsit5(), reltol=1e-8, abstol=1e-8)\nnothing # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"We plot the average photon number and the population inversion of the lasing transition.","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"n_t = real.(getindex.(sol.u, 1))\nÏƒ22m11_t = real.(2*getindex.(sol.u, 2) .+ getindex.(sol.u, 2) .-1 ) #Ïƒ11 + Ïƒ22 + Ïƒ33 = ðŸ™\n\n# Plot\np1 = plot(sol.t, n_t, xlabel=\"tÎ“â‚â‚‚\", ylabel=\"âŸ¨aâºaâŸ©\", legend = false)\np2 = plot(sol.t, Ïƒ22m11_t, xlabel=\"tÎ“â‚â‚‚\", ylabel=\"âŸ¨Ïƒ22âŸ© - âŸ¨Ïƒ11âŸ©\", legend = false)\nplot(p1, p2, layout=(1,2), size=(800,300))\nsavefig(\"3-level-laser.svg\") # hide","category":"page"},{"location":"examples/many-atom-laser/","page":"Many-atom level laser","title":"Many-atom level laser","text":"(Image: )","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Qumulants.jl offers a practical approach to the application of the generalized cumulant expansion method in Quantum Optics: operators are often represented by matrices on a Hilbert space, where a suitable basis has been chosen. These matrices can quickly become so large that they can no longer be stored. On a more abstract level, however, operators form a noncommutative alebgra that follows fundamental commutation relations. This is where Qumulants.jl comes in. The basic working principle boils down to the following steps:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The model (Hamiltonian) is specified.\nEquations of motion (Heisenberg equations) are symbolically derived for the system operators by using their fundamental commutation relations.\nThen follows the key step: the equations of motion for the noncommutative operators are averaged and truncated at a specified order neglecting higher-order quantum correlations using the generalized cumulant expansion method. This results in a closed set of c-number ordinary differential equations.\nFinally, the symbolic system of equations can be turned into a native Julia function which is directly usable in the DifferentialEquations.jl framework. This makes it straightforward to obtain a solution of the time dynamics of a system.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Qumulants.jl is not officially released (yet) and so has to be installed directly from GitHub. This can be done with","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"|pkg> add https://github.com/david-pl/Qumulants.jl.git","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For a full list of functions, check out the API.","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The basic usage is probably best illustrated with a brief example. In the following, we solve a simple model for a single-atom laser.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We start by loading the package, defining some symbolic parameters and the photonic annihilation operator a as well as the atomic lowering operator s. This allows us to quickly write down the Hamiltonian and the collapse operators of the system with their corresponding decay rates.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Latexify # hide\nset_default(double_linebreak=true) # hide\nusing Qumulants\n\n# Define parameters\n@parameters Î” g Î³ Îº Î½\n\n# Define hilbert space\nhf = FockSpace(:cavity)\nha = NLevelSpace(:atom,(:g,:e))\nh = hf âŠ— ha\n\n# Define the fundamental operators\na = Destroy(h,:a)\ns = Transition(h,:Ïƒ,:g,:e)\n\n# Hamiltonian\nH = Î”*a'*a + g*(a'*s + a*s')\n\n# Collapse operators\nJ = [a,s,s']\nrates = [Îº,Î³,Î½]\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now, we define a list of operators of which we want to compute the Heisenberg equations. We will only consider products of two operators. This is because later we will compute the dynamics of the system up to second order.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Derive a set of Heisenberg equations\nops = [a'*a,s'*s,a'*s]\nhe = heisenberg(ops,H,J;rates=rates)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The equations derived above are differential equations for operators. In order to convert them to c-number equations, we need to average over them. To obtain a closed set of equations, we expand higher-order products to second order.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Average the above equations and expand to second order\nhe_avg = average(he,2)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The first-order contributions are always zero and can therefore be neglected. You can try adding a and s to the list of operators ops in order to see that yourself. Or, even more conveniently, you can use complete(he_avg), which will automatically find all missing averages and compute the corresponding equations.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, though, we will proceed by finding the missing averages, and neglecting them as zero using the substitute function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Find the missing averages\nmissed = find_missing(he_avg)\n\n# Substitute them as zero\nsubs = Dict(missed .=> 0)\nhe_nophase = simplify_constants(substitute(he_avg, subs))","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, we can generate Julia code from the above set of equations which can be solved directly using the OrdinaryDiffEq.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Generate a Julia function that to solve numerically\np = (Î”, g, Î³, Îº, Î½)\nf = generate_ode(he_nophase,p)\n\n# Solve the system using the OrdinaryDiffEq package\nusing OrdinaryDiffEq\nu0 = zeros(ComplexF64,length(ops))\np0 = (0, 1.5, 0.25, 1, 4)\nprob = ODEProblem(f,u0,(0.0,10.0),p0)\nsol = solve(prob,RK4())\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The photon number of our laser and the excited state population of the atom are now stored in the first two fields of sol.u.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Plots\nn = real.(getindex.(sol.u, 1))\npe = real.(getindex.(sol.u, 2))\nplot(sol.t, n, label=\"Photon number\", xlabel=\"t\")\nplot!(sol.t, pe, label=\"Excited state population\")\nsavefig(\"tutorial.svg\") # hide\nnothing # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: Photon number and excited state population)","category":"page"}]
}
